// This is like a header file in c, called cginc (C for graphics include)
// And its going to contain all required functions and structs
// For our basic shaders
// It is really good practice to keep all the shaders stuff in cginc file

// These pre-processor macros required to avoid duplicated including
// https://gcc.gnu.org/onlinedocs/gcc-3.0.2/cpp_2.html (Check 2.4 Once-Only Headers)
#ifndef ALL_CODE_REQUIRED_FOR_DEFERRED_RENDERING_PATH
#define ALL_CODE_REQUIRED_FOR_DEFERRED_RENDERING_PATH

#include "../../SharedCode.cginc"

// Data generated by unity CPU side and passed to vertex function
struct VertData
{
	float4 vertex : POSITION; /* vertex naming required by TRANSFER_SHADOW */
	float3 normal : NORMAL;
	float2 uv : TEXCOORD0;
};

// Data generated by geometry function and combined with render target
struct FragData
{
	float4 pos : SV_POSITION; /* SV_POSITION specifies that this is our pixel position */
	float3 worldNormal : NORMAL;
	float2 uv : TEXCOORD0;
};

//Vertex function/shader
FragData vertDeferred(VertData v /* v naming required by SHADOW_COORDS */)
{
	FragData o;
	o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
	o.worldNormal = UnityObjectToWorldNormal(v.normal);
	o.uv = v.uv;
	return o;
}

// Sampler + texture this is how it actually looks:
// struct sampler2D { Texture2D t; SamplerState s; };
// So when call function like tex2D (Its macro), its translated into
// float4 tex2D(sampler2D x, float2 v)				{ return x.t.Sample(x.s, v); }
sampler2D _MainTex;
float4 _Color;

// Its not really accurate naming
// But for this function we calculate color for real object texture or its so called material
// This same color is used for deferred rendering GBuffer
inline fixed4 CalculateDiffuseColor(float2 uv)
{
	fixed4 diffuseColor = tex2D(_MainTex, uv) * _Color; // Object texture
	return diffuseColor;
}

// Fragment function/shader for deferred.
void fragDeferred
(
	FragData i,

	// Shaders allow drawing on multiple color buffers, this feature is present in mid end gpus.
	out half4 outDiffuse : SV_Target0,
	out half4 outSpecSmoothness : SV_Target1,
	out half4 outNormal : SV_Target2,
	out half4 outEmission : SV_Target3
)
{
	fixed4 diffuse = fixed4(0, 0, 0, 0);
	diffuse += CalculateDiffuseColor(i.uv);
	// We don't need to calculate any lights, because deferred has it built-in.

	fixed4 normal = fixed4(i.worldNormal, 1);

	outDiffuse = diffuse;
	outSpecSmoothness = 0.2;
	outNormal = normal;
	outEmission = 1;
}

#endif // ALL_CODE_REQUIRED_FOR_DEFERRED_RENDERING_PATH