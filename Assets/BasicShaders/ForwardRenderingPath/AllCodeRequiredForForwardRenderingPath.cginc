// This is like a header file in c, called cginc (C for graphics include)
// And its going to contain all required functions and structs
// For our basic shaders
// It is really good practice to keep all the shaders stuff in cginc file

// These pre-processor macros required to avoid duplicated including
// https://gcc.gnu.org/onlinedocs/gcc-3.0.2/cpp_2.html (Check 2.4 Once-Only Headers)
#ifndef ALL_CODE_REQUIRED_FOR_FORWARD_RENDERING_PATH
#define ALL_CODE_REQUIRED_FOR_FORWARD_RENDERING_PATH

#include "../../SharedCode.cginc"

// Data generated by unity CPU side and passed to vertex function
struct VertData
{
	float4 vertex : POSITION; /* vertex naming required by TRANSFER_SHADOW */
	float3 normal : NORMAL;
	float2 uv : TEXCOORD0;
};

// Data generated by geometry function and combined with render target
struct FragData
{
	float4 pos : SV_POSITION; /* SV_POSITION specifies that this is our pixel position */
	float3 worldNormal : NORMAL;
	float2 uv : TEXCOORD0;
	float3 worldPos : TEXCOORD1;
	SHADOW_COORDS(2) /* Adds if needed shadow coordinates value, depends from current light */
};

//Vertex function/shader
FragData vertForward(VertData v /* v naming required by SHADOW_COORDS */)
{
	FragData o;
	o.pos = mul(UNITY_MATRIX_MVP, v.vertex);
	o.worldNormal = UnityObjectToWorldNormal(v.normal);
	o.uv = v.uv;
	o.worldPos = mul(unity_ObjectToWorld, v.vertex);
	TRANSFER_SHADOW(o); // Calculates shadow coordinates.
	return o;
}

// Sampler + texture this is how it actually looks:
// struct sampler2D { Texture2D t; SamplerState s; };
// So when call function like tex2D (Its macro), its translated into
// float4 tex2D(sampler2D x, float2 v)				{ return x.t.Sample(x.s, v); }
sampler2D _MainTex;
float4 _Color;

// Its not really accurate naming
// But for this function we calculate color for real object texture or its so called material
// This same color is used for deferred rendering GBuffer
inline fixed4 CalculateDiffuseColor(float2 uv)
{
	fixed4 diffuseColor = tex2D(_MainTex, uv) * _Color; // Object texture
	return diffuseColor;
}

// Fragment function/shader for forward base (Directional light).
// Also know as pixel shader, it might sound more correct name, because its output pixel color.
// However because of MSAA (Multisample anti-aliasing), fragment function could be called multiple times per same pixel.
// So its more correct to call it fragment and not pixel.
fixed4 fragForwardBase(FragData i) : SV_TARGET /* SV_TARGET/COLOR is our lord semantic that says return value will be our output color*/
{
	fixed4 finalColor = fixed4(0, 0, 0, 0);

	// This define does a lot of stuff.
	// Calulcates the light contribution to object and if shadow covers it.
	UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos);

	fixed4 diffuseColor = CalculateDiffuseColor(i.uv);
	fixed3 lightColor =  CalculateDirectionalLight(i.worldNormal);
	finalColor.rgb += diffuseColor.rgb * lightColor * attenuation;
	finalColor.a = diffuseColor.a;

	fixed3 ambientColor = CalculateAmbientColor();
	finalColor.rgb += ambientColor;

	return finalColor;
}

// Fragment function/shader for foward add (Spot/Point/Cookies light).
fixed4 fragForwardAdd(FragData i) : SV_TARGET
{
	fixed4 finalColor = fixed4(0, 0, 0, 0);

	// This define does a lot of stuff.
	// Calulcates the light contribution to object and if shadow covers it.
	UNITY_LIGHT_ATTENUATION(attenuation, i, i.worldPos);

	// Forward add pass can be caused not only by spot and point lights, so we make sure not
	// to do this calculations in them.
	#if defined (POINT) || (SPOT)
		fixed3 pointLight = CalculatePointOrSpotLight(i.worldNormal, i.worldPos, _WorldSpaceLightPos0.rgb, _LightColor0.rgb, _LightColor0.a);
		finalColor.rgb += pointLight * attenuation;

	#endif

	return finalColor;
}

#endif // ALL_CODE_REQUIRED_FOR_FORWARD_RENDERING_PATH