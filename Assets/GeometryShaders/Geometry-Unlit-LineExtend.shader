// This shader uses geometry function to extend lines

Shader "Tests/Unlit/LineExtend"
{
	// For unity UI
	Properties
	{
		_Color("Main Color", Color) = (1,1,1,1)
		_Offset("Offset", Float) = 0.1
		// https://docs.unity3d.com/ScriptReference/MaterialPropertyDrawer.html
		[KeywordEnum(Triangle, Line, Point)] _Geometry("Geometry mode", Float) = 0
	}

	SubShader
	{
		Pass
		{
			Tags
			{
				"LightMode" = "ForwardBase" // Specifies unity that this pass should be used in foward rendering for directional light
			}

			CGPROGRAM // Indicates CG start (C for graphics)

			// Here we specify the shader function names
			#pragma vertex vert // Specifies the vertex function name
			#pragma geometry geo // Specifies the geometry function name
			#pragma fragment frag // Specifies the fragment function name

			// Multi compile specify unity that we need multiple varations of this shader
			// Then material will decide with keywords which varation it should use
			// It really saves us a time, because we don't need to write lots of diffrent source varations
			#pragma multi_compile _GEOMETRY_TRIANGLE _GEOMETRY_LINE _GEOMETRY_POINT 

			// You might already know that shader don't have include files
			// This is unity created thing
			// So what it does copies the source code to our shader
			#include "UnityCG.cginc" // Include basic unity functions and built in values veriables
			#include "Lighting.cginc" // Includes some lighting veriables

			#include "../SharedCode.cginc"

			// Data generated by unity CPU side and passed to vertex function
			struct VertData
			{
				float4 pos : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};

			// Data generated by vertex function and passed to fragment function
			struct GeoData
			{
				float4 pos : POSITION;
				float3 normal : NORMAL;
			};

			// Data generated by geometry function and combined with render target
			// final output color depends from color blend operations.
			struct FragData
			{
				float4 pos : SV_POSITION; /* SV_POSITION specifies that this is our pixel position */
				float3 normal : NORMAL;
			};

			//Vertex function/shader
			GeoData vert(VertData i)
			{
				GeoData o;
				o.pos = i.pos;
				o.normal = i.normal;
				return o;
			}

			fixed4 _Color;
			fixed _Offset;

			// This function calculate rotation matrix from direction
			// it is hard coded so don't try to figure it out.
			inline float4x4 CalculateDirectionToMatrix(float4 direction)
			{
				float4 forward = direction;
				float4 up = float4(0, 1, 0, 0);
				float4 side = float4(0, 0, 0, 0);
				
				side.rgb = cross(forward.rgb, up.rgb);
				if (length(side) < 0.001f)
				{
					side.rgb = cross(forward.rgb, float3(0, 1, 0));
					if (length(side) < 0.001f)
						side.rgb = cross(forward, float3(1, 0, 0));
				}

				side = normalize(side);
				up.rgb = cross(forward, side);

				// example, depends solely on the matrix format and coordinate space used
				float4x4 rotation = float4x4(forward, side, up, float4(0, 0, 0, 1));
				rotation = transpose(rotation);
				return rotation;
			}

			inline float4 TransformToWorldSpace(float4 position, float4 direction, float4 offset, float4x4 rotation)
			{
				float4 toObjectSpace = mul(rotation, direction + _Offset * offset) + position;
				float4 toWorldSpace = mul(UNITY_MATRIX_MVP, toObjectSpace);
				return toWorldSpace;
			}

			inline float3 TransformToWorldSpaceNormal(float4 direction, float4x4 rotation)
			{
				float4 toObjectSpace = mul(rotation, direction);
				float3 toWorldSpace = UnityObjectToWorldNormal(toObjectSpace);
				return toWorldSpace;
			}

			[maxvertexcount(10)] // Specifies maximum vertex count in outStream, can be smaller
			// Geometry function/shader
			void geo
			(
				line GeoData i[2], // Data from vertex function

				// Data that will be passed to fragment function
				#if defined(_GEOMETRY_TRIANGLE)
					inout TriangleStream<FragData> outStream
				#elif defined(_GEOMETRY_LINE)
					inout LineStream<FragData> outStream
				#else
					inout PointStream<FragData> outStream
				#endif
			)
			{
				float4 castPosition = i[0].pos;
				float castDistance = length(i[1].pos - i[0].pos);
				float4 castDirection = normalize(i[1].pos - i[0].pos);
				float4x4 rotationMatrix = CalculateDirectionToMatrix(castDirection);
				float4 startDirection = float4(0, 0, 0, 0);
				float4 endDirection = float4(castDistance, 0, 0, 0);
				float4 upDirection = float4(0, 1, 0, 0);
				float4 downDirection = float4(0, -1, 0, 0);
				float4 leftDirection = float4(0, 0, 1, 0);
				float4 rightDirection = float4(0, 0, -1, 0);

				// Calculate vertices, we could make it a bit cleaner with loops
				// but remember shaders don't have stack it means no jumps
				// so even loops would be optimized into this at some point.
				FragData vertex[8];
				vertex[0].pos = TransformToWorldSpace(castPosition, startDirection, upDirection, rotationMatrix);
				vertex[1].pos = TransformToWorldSpace(castPosition, startDirection, downDirection, rotationMatrix);
				vertex[2].pos = TransformToWorldSpace(castPosition, startDirection, leftDirection, rotationMatrix);
				vertex[3].pos = TransformToWorldSpace(castPosition, startDirection, rightDirection, rotationMatrix);
				vertex[4].pos = TransformToWorldSpace(castPosition, endDirection, upDirection, rotationMatrix);
				vertex[5].pos = TransformToWorldSpace(castPosition, endDirection, downDirection, rotationMatrix);
				vertex[6].pos = TransformToWorldSpace(castPosition, endDirection, leftDirection, rotationMatrix);
				vertex[7].pos = TransformToWorldSpace(castPosition, endDirection, rightDirection, rotationMatrix);

				vertex[4].normal = vertex[0].normal = TransformToWorldSpaceNormal(upDirection, rotationMatrix);
				vertex[5].normal = vertex[1].normal = TransformToWorldSpaceNormal(downDirection, rotationMatrix);
				vertex[6].normal = vertex[2].normal = TransformToWorldSpaceNormal(leftDirection, rotationMatrix);
				vertex[7].normal = vertex[3].normal = TransformToWorldSpaceNormal(rightDirection, rotationMatrix);

				// Fill the stream with vertices.
				outStream.Append(vertex[0]);
				outStream.Append(vertex[4]);
				outStream.Append(vertex[3]);
				outStream.Append(vertex[7]);
				outStream.Append(vertex[1]);
				outStream.Append(vertex[5]);
				outStream.Append(vertex[2]);
				outStream.Append(vertex[6]);
				outStream.Append(vertex[0]);
				outStream.Append(vertex[4]);
			}

			// Fragment function/shader
			// Also know as pixel shader, it might sound more correct name, because its output pixel color
			// However because of MSAA (Multisample anti-aliasing), fragment function could be called multiple times per same pixel
			// So its more correct to call it fragment and not pixel
			fixed4 frag(FragData i) : SV_TARGET /* SV_TARGET/COLOR is our lord semantic that says return value will be our output color */
			{
				fixed4 finalColor = fixed4(0, 0, 0, 0);
				fixed4 diffuseColor = _Color;
				fixed3 lightColor = CalculateDirectionalLight(i.normal);
				finalColor.rgb += diffuseColor.rgb * lightColor + CalculateAmbientColor();
				finalColor.a = diffuseColor.a;
				return finalColor;
			}

			ENDCG // Ends the CG code
		}
	}
}
