// This shader uses geometry function to generate one additional vertex in center of triangle
// so it creates the effect of spikes.
// This shader is only for showcase and testing, using geometry this way is not really effecient.

Shader "Tests/Geometry/CustomLightingModel/CentricVertex"
{
	// For unity UI
	Properties
	{
		_Color("Main Color", Color) = (1,1,1,1)
		_MainTex("Main Texture", 2D) = "white" {}
		_Offset("Offset", Float) = 0.1
		// https://docs.unity3d.com/ScriptReference/MaterialPropertyDrawer.html
		[KeywordEnum(Triangle, Line, Point)] _Geometry("Geometry mode", Float) = 0
	}

	SubShader
	{
		Pass
		{
			Tags
			{
				"LightMode" = "ForwardBase" // Specifies unity that this pass should be used in foward rendering for directional light
			}

			CGPROGRAM // Indicates CG start (C for graphics)

			// Here we specify the shader function names
			#pragma vertex vert // Specifies the vertex function name
			#pragma geometry geo // Specifies the geometry function name
			#pragma fragment frag // Specifies the fragment function name

			// Multi compile specify unity that we need multiple varations of this shader
			// Then material will decide with keywords which varation it should use
			// It really saves us a time, because we don't need to write lots of diffrent source varations
			#pragma multi_compile _GEOMETRY_TRIANGLE _GEOMETRY_LINE _GEOMETRY_POINT 

			// You might already know that shader don't have include files
			// This is unity created thing
			// So what it does copies the source code to our shader
			#include "UnityCG.cginc" // Include basic unity functions and built in values veriables
			#include "Lighting.cginc" // Includes some lighting veriables

			#include "../SharedCode.cginc"

			// Data generated by unity CPU side and passed to vertex function
			struct VertData
			{
				float4 pos : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};

			// Data generated by vertex function and passed to fragment function
			struct GeoData
			{
				float4 pos : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};

			// Data generated by geometry function and combined with render target
			struct FragData
			{
				float4 pos : SV_POSITION; /* SV_POSITION specifies that this is our pixel position */
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
				fixed3 pointLightColor : TEXCOORD1; /* Point light color calculated in geometry shader*/
			};

			//Vertex function/shader
			GeoData vert(VertData i)
			{
				GeoData o;
				o.pos = i.pos;
				o.normal = i.normal;
				o.uv = i.uv;
				return o;
			}

			sampler2D _MainTex;
			fixed4 _Color;
			fixed _Offset;

			// By default all shader functions are inlined,
			// But I like to write it, just to keep it in mind
			inline FragData calculateCentricVertex(FragData base0, FragData base1, FragData base2, float offset)
			{
				float4 pos = (base0.pos + base1.pos + base2.pos) / 2;
				float3 normal = (base0.normal + base1.normal + base2.normal) / 2;
				float2 uv = (base0.uv + base1.uv + base2.uv) / 2;
				pos += float4(normal, 0) * offset;
				FragData o;
				o.pos = pos;
				o.normal = normal;
				o.uv = uv;
				return o;
			}

			[maxvertexcount(5)] // Specifies maximum vertex count in outStream, can be smaller
			// Geometry function/shader
			void geo
			(
				triangle GeoData i[3], // Data from vertex function

				// Data that will be passed to fragment function
				#if defined(_GEOMETRY_TRIANGLE)
					inout TriangleStream<FragData> outStream
				#elif defined(_GEOMETRY_LINE)
					inout LineStream<FragData> outStream
				#else
					inout PointStream<FragData> outStream
				#endif
			)
			{
				// Takes three triangle vertices
				FragData vertex[3];
				for (int index = 0; index < 3; index++)
				{
					vertex[index].pos = i[index].pos;
					vertex[index].normal = i[index].normal;
					vertex[index].uv = i[index].uv;
				}

				// Calculate vertex that is located in center of triangle
				FragData centricVertex;
				centricVertex = calculateCentricVertex(vertex[0], vertex[1], vertex[2], _Offset);

				// Transforming the normals, otherwise rotations won't affect it
				vertex[0].normal = UnityObjectToWorldNormal(vertex[0].normal);
				vertex[1].normal = UnityObjectToWorldNormal(vertex[1].normal);
				vertex[2].normal = UnityObjectToWorldNormal(vertex[2].normal);
				centricVertex.normal = UnityObjectToWorldNormal(centricVertex.normal);

				// We can't calculate point lights in fragment shader, because values are not updated there
				vertex[0].pointLightColor = CalculatePointLights(vertex[0].normal, mul(unity_ObjectToWorld, vertex[0].pos));
				vertex[1].pointLightColor = CalculatePointLights(vertex[1].normal, mul(unity_ObjectToWorld, vertex[1].pos));
				vertex[2].pointLightColor = CalculatePointLights(vertex[2].normal, mul(unity_ObjectToWorld, vertex[2].pos));
				centricVertex.pointLightColor = CalculatePointLights(centricVertex.normal, mul(unity_ObjectToWorld, centricVertex.pos));

				// Transforming from object space into screen space
				vertex[0].pos = mul(UNITY_MATRIX_MVP, vertex[0].pos);
				vertex[1].pos = mul(UNITY_MATRIX_MVP, vertex[1].pos);
				vertex[2].pos = mul(UNITY_MATRIX_MVP, vertex[2].pos);
				centricVertex.pos = mul(UNITY_MATRIX_MVP, centricVertex.pos);


				// Fill the stream with vertices
				outStream.Append(vertex[0]);
				outStream.Append(vertex[1]);
				outStream.Append(centricVertex);
				outStream.Append(vertex[2]);
				outStream.Append(vertex[0]);
			}

			// Its not really accurate naming
			// But for this function we calculate color for real object texture or its so called material
			// This same color is used for deferred rendering GBuffer
			inline fixed4 CalculateDiffuseColor(float2 uv)
			{
				fixed4 diffuseColor = tex2D(_MainTex, uv) * _Color; // Object texture
				return diffuseColor;
			}
			// Calculate all lights that contribute to this pixel
			inline fixed3 CalculateLightColor(float3 normal, fixed3 pointLightColor)
			{
				fixed3 lightColor = fixed3(0, 0, 0);
				lightColor += CalculateDirectionalLight(normal);
				lightColor += pointLightColor; // CalculatePointLights(normal, worldSpacePosition);
				return lightColor;
			}

			// Fragment function/shader
			// Also know as pixel shader, it might sound more correct name, because its output pixel color
			// However because of MSAA (Multisample anti-aliasing), fragment function could be called multiple times per same pixel
			// So its more correct to call it fragment and not pixel
			fixed4 frag(FragData i) : SV_TARGET /* SV_TARGET is our lord semantic that says return value will be our output color*/
			{
				fixed4 finalColor = fixed4(0, 0, 0, 0);

				fixed4 diffuseColor = CalculateDiffuseColor(i.uv);
				fixed3 lightColor = CalculateLightColor(i.normal, i.pointLightColor);
				finalColor.rgb += diffuseColor.rgb * lightColor;
				finalColor.a = diffuseColor.a;

				fixed3 ambientColor = CalculateAmbientColor();
				finalColor.rgb += ambientColor;

				return finalColor;
			}

			ENDCG // Ends the CG code
		}
	}
}
